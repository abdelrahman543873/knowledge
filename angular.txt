directives are instructions in the dom , an example of directives are components , after we create them , and then we try to place them in the dom , this is instructing angular to put them in the dom ,
there are also directives without templates , and they are created by @Directive decorator above our directive class , directives like css class could be applied as attributes to our templates in the html dom 

*ngIF="expression returning true or false" : this is a structural directive that allows angular to show a component if the expression between the "" evaluated to true
example :
*ngIF="expression; else anotherExpression"

<ng-template #noServer></ng-template> : this is an angular element that you can reference using the noServer attribute anywhere in the dom

attribute Directives : directives that doesn't remove or add elements like structural directives , it only changes the directives that it's on 

[ngStyle] = {"backgroundColor:function()"} : this is an attribute directive that is going to change the color of the element that it's on using the value returned from the function

[ngClass] = "{online: boolean expression}" : this will attach this class to the element if the expression evaluates to true 

*ngFor="let variable of list" : a structural directive that allows you to repeat an element for number of times 

{{variable}} : this is called string interpolation where you log the value of a variable from your typescript code 

ng g c something/recipes --skipTests false : allows you to generate a component without creating the testing file and it would create the recipes folder inside the something folder

ng g d value : this will generate a directive and it has all the options of generating a component

custom property binding : @input('alias'), is a property decorator , that allows the property of an component to be accessible from outside this component , if you enter the optional alias string , it will assign the value of that
alias to that property and the alias will be the way of referencing the property outside this element

<h1 (event) = "function($event)"/> : this will pass the data of this event to the function

@Output('alias') : is a property decorator for event event emitter that allows you to output event data to parent components , alias is going to be the name of the event when you reference it from outside your component
example: 
@Output() something = new EventEmitter<type>(),
now this something event could be listened to from parent elements and executed once the event was emitted

view Encapsulation: is a feature of angular that limits styles to their component only 

@Component({Encapsulation:ViewEncapsulation.None}): this will disable the view encapsulation mechanism of angular and any style you apply to this component will be applied globally

<input #localReference/> : this allows you to reference an html element locally in the same template , and then you can pass it as an input to other functions in the html template 

@ViewChild('localReference selector') classProperty : this will allow the selection of an element using the local reference selector of the element we want to select, it will return a refElement , this ref Element could be used to get 
the underlying nativeElement and then get any DOM property from the native element 

viewChildElement.nativeElement.value : this is how you will get the value of a selector element 

in general , everything that you place between the opening and closing of a component will be lost and won't be rendered

<ng-content></ng-content> : a directive that allows you to add html elements to your components from outside the component itself
example:
you have this component
<div>
<ng-content></ng-content> 
</div> : then any data that is added from another outside component using this component will be added between the DIVs 
of if you add in the parent component <div><p></p></div> the paragraph element will be passed inside the div

lifCycle hooks of components:
ngOnChanges(changes:simpleChanges): first instantiated hook and is always called when changes happens to components and by changes we mean changes in any class properties that are decorated by the @input decorator and it's the
only hook that receives a parameter which are the changes that happened
ngOnInit: second instantiated hook that is instantiated right before the component appears on the screen and it will run after the constructor
ngDoCheck : is instantiated whenever angular checks for changes on the component 
ngAfterViewInit: is instantiated when the view is initialized on the screen
ngOnDestroy: is called when the component is removed or destroyed in the dom

@ContentChild('localRef') classProperty : this allows you to access content that is rendered inside your component from an external component

[ngClass] = {'valueOfClass: condition'}: a style directive , that allows you to choose a certain class if a condition
is satisfied

@Directive({
	selector:"[appBasicHighlight]"
})
export class BasicHighlightDirective implements OnInit{
	constructor(private ElementRef:ElementRef){}

	ngOnInit(){
		this.elementRef.nativeElement.style.backgroundColor = 'green'
	}
} : this is how you create a directive , and this is going to be an attribute
directive , that could be used for styling elements , here it will change the color of any element that it's placed
on to be green and then if you want to use this directive you do this
<p appBasicHighlight></p>

constructor(private elRef:ElementRef, private renderer:Renderer2){
	this.renderer.setStyle(this.elRef.nativeElement, 'background-color','green')
}
: this is the proper way to access the element from the dom  , and this should be done inside a directive for styling elements , this is better way than the previous code 

@HostListener('mouseenter') function(){} : this allows you to interact on certain events , for example here , this function will be triggered whenever the mouse is hovered over the element of the directive

the dom properties are camel cased and the html attributes are separated using a dash

@HostBinding('style.backgroundColor') backgroundColor:string 
this.backgroundColor ='blue'
this code will allow you to access the style properties of the element that this directive will sit on 

@Input() inside a directive allows you to pass values to the directive to customize it's behavior and then if you want to pass the values you pass it like this
<p directive [directiveProperty] = "'value'"></p> or  <p directive directiveProperty = "value"></p>

*ngIf is a syntactical sugar for ng-template so this
<div *ngIf></div> is equal this <ng-template [ngIf]><div></div></ng-template> 
and that's cause angular only has property , event , two way binding and interpolation only and this * doesn't exist

you can create your own structural directive by creating a setter method of the class of the directive like this
@Directive({
	selector:'structuralDirectiveName'
})
export class(){
	@Input() set structuralDirectiveName(condition:boolean){
		your code sets here
	}
}
and then if you want to use it , you add a start before it and you need to have the property and the selector with the same name 

[ngSwitch] : this is a directive that allows you to switch views based on different conditions and it's used like this
<div [ngSwitch]="changingValue">
  <p *ngSwitchCase="5">5</p>
  <p *ngSwitchCase="6">6</p>
</div>

service injection in angular is hierarchal which means if a parent uses a service then it's inherited by it's children

@injectable({providedIn:'root'}) : is a decorator for any class that could be injected from other classes but you should add at to all classes injecting or being injected as this is the recommendation by angular 
, the parameter providedIn will make this service global because of the root value , and this is better approach cause it allows lazy loading in angular

it's best practice to initialize properties in onInit in components

const appRoutes:Routes=[{path:"users",component:Component,children:[{path:"",component:Component}]}] : this is where you place the routes of the app , that
allows you to navigate between components , the path is the string that is place after the url of the website and 
the component is what get loaded when you go to that url , and the children route will allow you to go to another child route , which means it will be an extension of the main route

we should have an empty route like this [{path:'',component: DefaultComponent}], this means that this will be the component that will be loaded
when no path is selected

RouterModule.forRoot(appRoutes) : this will control the routes of your app and it's imported in the app module

<router-outlet></router-outlet> : this directive tells angular where to render the component of the route

<a routerLink="/"></a> : this will make angular handle the routing which will prevent the app from reloading with
with each click which is the normal behavior if we use href
routerLink="path" : this will navigate to the relative path which means that it will add the path to the path you are currently on
routerLink="/path" : this will navigate to the absolute path which means that it will add the path to the absolute url of the website
routerLink="./path": this directory like path will navigate up one level and then go to the mentioned path 

routerLinkActive="active" : this will change the style of the selected routing element to active in this case to 
mark that it's selected , the active is the name of the class that is going to be activated when the app is sitting on the current route

[routerLinkOptions]="{exact:true}" : this angular property is used for configuring the options for the routerLinkActive
directive , and the exact make links activate if they are only refereed to exactly

[queryParams] = {allowEdit:true} : this is a parameter option for routerLink that allows you to add query parameters to the router

fragment = "value" : a fragment option of routerLink that adds a fragment to the route which is #value in this case

this.router.navigate(['servers'],{relativeTo:'the base router you want',queryParamsHandling:'preserve'}) : the router service that is injected in the constructor allows you to navigate 
to other routes "/ or no / doesn't matter" using the navigate function as the router service doesn't know which route we are sitting on, and
the relative to property determines the base route
queryParamsHandling: this will determine what happens if you redirect from this route and in this case it will preserve the route parameters

subscriptions for angular aren't destroyed automatically in usual and you need to destroy them by implementing onDestroy function  

this.activatedRoute : this will get you the route of the current component that you are in 

this.activatedRoute.snapshot.params['id'] : this will use the activated Route service of angular and get the id parameter from the url , this is static , and will be only loaded when the component first initializes

this.activatedRoute.params.subscribe((params:Params)=>{your code}) : this code will get executed whenever the parameters of the route gets changed  "use this only when your component is could be reloaded from inside itself" 

this.activatedRoute.queryParams and this.activatedRoute.snapshot.queryParams and the same exist for fragment to with the same methodology

[routerLink]="['/users',10,'something'] : this is the best way to pass url to router link , it will construct the following url , something.com/user/10/something

const path = [{path:"users/:id",component:Component}] : this is how to pass parameters to a url
const path = [{path:"users/:id",redirectTo:'path'}] : in the case this url was typed , it will redirect to another path , because of the the redirect to property 

const path = [{path:"**",component:Component}] : in this case the ** means that all the routes that aren't included will be redirected to this component and it has to be the last route cause order 
is very important when it comes to routes

const path = [{path:"users/:id",redirectTo:'path', pathMatch:'full'}] : this will redirect only to full path of the url in path and will avoid redirecting to paths that has the same partial url

@NgModule({})
export class module{} : this is how you create modules in angular

export class AuthGuard implements canActivate {
	canActivate(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean{
		your code logic that returns true or false
		and if false it should redirect to another 
		webpage using 
		this.Router.navigate() function
	}
	canActivateChild(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean{
		your code logic that returns true or false
		and if false it should redirect to another 
		webpage using 
		this.Router.navigate() function
		this allows you to protect child routes without having to manually place the can activate on children paths
	}
}

const path = [{canActivate:[GuardService],canDeactivate:[guard],canActivateChild:[guard] path:"users/:id",component:Component}] : the can deactivate 
guard allows you to either leave the route or not and the canActivate property allows you to enter the route or not 
and canActivateChild will only protect the children routes but not the parent route

const path = [{path:"**",component:Component, data:{}}] : this allows you to pass data to the component and then if you want to access this data you do it like this
this.activatedRoute.snapshot.data['the property you want to access'] or you can subscribe to the data Observable like this this.route.data.subscribe()

export class serverResolver implements Resolve<DataTypeToBeResolved>{
	resolve(route:ActivatedRouteSnapshot,state:RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {}
}

const path = [{path:"**",component:Component, resolve:{propertyName:ResolverServiceName}}] : the resolve property will allow you to load data dynamically before loading the component and it will map it to the propertyName property
and it's accesses using this.activatedRoute.subscribe((propertyName)=>{}) to get the data 

RouterModule.for(appRoutes,{useHash:true}): useHash allows for the legacy # in the routes to allow for better redirection when the angular app is hosted online 

onDestroy is triggered whenever the component is destroyed like for example when you leave the component

the observer in the rxjs create observable method , has three methods
error : what is thrown to the observer when there is an error
next : what is throw to the observer when data is emitted
complete : when the observable is done what is thrown to the observer 
it looks like this 
const customObservable = Observable.create(observer=>{observer.error(new Error() 'errorObject') or observer.next(dataYouWantToPass) or observer.complete()})
if i would like to handle everything coming from this observable it would be like this
customObservable.subscribe(data=>{console.log('data')},error=>{console.log(error),()=>{console.log('completion')}})

in observables completion is different that errors , if your observers throws an errors then it doesn't complete , it's two different things

operators : are transformations that you could apply on the data before receiving it on the observer side , using this function
observable.pipe('use functions from rxjs like map','another rxjs function', ....).subscribe() : this is the way to use operators with observables

subject : is a special type of observable that is more interactive where you can trigger the next function from outside the subject not from the inside as in the case of the normal observable 
and it can't be used with the @Output from angular and it could be subscribed to normally as you do with observable
subjects are also more efficient than observables

you use subjects with your services to emit events which is better

two templates approaches are available in angular :
template-driven : where you make you html template 
reactive approach : where the form is created from the code and synchronized with the dom 


ngModel : inside forms , this is an angular directive that allows you to control a form element from the dom , and it's syntax is like this
<input type="text" ngModel name="theNameThatIsGoingToBeRepresentedInTheDom"/>

ngSubmit : is an angular event that makes use of the default behavior of the submit button on a form , it's placed on forms like this
#localRef="ngForm" : this gives you access to the form object created by angular "the type of ngForm is ngForm" 
ngForm.value : this is the object you want to access to get the values of the elements you have referenced by ngModel in the form 
<form (ngSubmit)="theFunctionYouWantToTrigger(anyName)" #anyName="ngForm">
<button type="submit"></button>
</form>
here in the previous code we triggered a function on submitting the form and in this function we passed the ngForm object created by angular
you can access the anyName local reference by either passing it through the function or using @ViewChild('anyName') like this
@ViewChild('anyName') propertyName , and this way is used if you need to access the form at any other point other than submitting the form

required: a validation html attribute that angular treats as a directive , that makes sure the element value isn't null it's used like this 
<input type="text" name="something" required/>

email : is a validator directive in angular that validates if an input is an email or not

valid : a property of the ngForm that checks if all your form validation is valid or not and it's a property of the individual form elements too 

localRef.value : you can access the properties of the local reference of elements using the normal dot notation in the html 
example
<button [disabled]="formLocalRef.valid != true"></button> : this will only enable the submit button if the form validation passes 

input.ng-invalid {
	border:1px solid red
}: this is an example of how to make the border become red if the input that the user is passing is invalid

<input type="email" ngModel #email="ngModel"/>: this will allow you to access the email input properties like this for example
<span *ngIf="!email.valid>wrong email</span> : this will show a message error if the input value of the email is wrong 

<select [ngModel]="'value'"> : this allows you to choose a default value for the select 

[(ngModel)]="classProperty" : this will be a reactive approach to the input the user is entering 

@ViewChild('selector') something
something.setValue({propriety of the element selected and their values}) : this will override the values of the whole form
something.form.patchValue({property you want to override}) : this will override only the value of the property you pass 
something.reset() : resets the whole form for you 

@NgModule is imported from forms module

the first file that is loaded in angular apps is the main.ts file and it's the one the allows the selectors in the index.html file to be defined 

the bootstrap property of the NgModule decorator , tells angular which components should be firstly initialized in the index.html file while bootstrapping the app

in string interpolation you can call a function

[property]="someProperty" : this is called property binding it binds a DOM property to the property in the ts 

(click)="someFunction($event)" : this is called event binding where we bind dom events to functions in our ts code passes the data from the event to the bound function

[(ngModel)]="variable" : this is two way binding that will trigger on both sides

ng g c folder/component : this will create the component inside the specified folder

source maps : are cli added feature that allows us to trace our js code back to it's typescript source in the browser

in the browser under webpack you can find the . folder which has the src folder of the project

all elements of a component are by default accessible only from the component , and this allows for the concept of view encapsulation

view encapsulation enforces css files to be scoped only to the component they are in 

*ngIf = "elementRef; else anotherElementRef" : this will allow you to show elements based on if else conditioning

attribute directives : are directives that sit on elements as properties and change the properties of the element

structural directives: are directives that change the dom of the html they are sitting on 

[ngClass]="{class: condition}" : this will style the element that it's sitting on with the property class if the condition resolves to true 

[ngStyle]="{backgroundColor: value? 'blue': 'red'}" : this will style the element with the mentioned property if the conditions evaluates to true

camel casing is used with directive selectors

we can create directives that could be used with our elements easily , example : 
@Directive({
	selector: '[appDirective]'
})
export class AppDirective implements onInit{
	constructor(private decoratedElement: ElementRef){}
	onInit(){
		this.decoratedElement.nativeElement.backgroundColor = 'blue'
	}
}
this way this directive will change the background color of any element it's sitting on to blue and the brackets in the selector tells angular
that this is going to be property of an element it's sitting on and this is how we use it 
<p appDirective></p>
but it's a bad practice to access our elements directly and change them , like done in here so we should use the renderer as following
@Directive({
	selector: '[appDirective]'
})
export class AppDirective implements onInit{
	constructor(private decoratedElement: ElementRef, private renderer: Renderer2){}
	onInit(){
		this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue')
	}
}
this is a better way of accessing the element the directive is sitting on cause angular isn't only limited to running in the browser , for
example it might run with service workers so this place might not have access to the dom

@HostBinding()

services are inherited by child components so , if you provide app component with a service all it's children will inherit the same instance of 
that service

this.router.navigate(['link', id , 'edit'],{queryParams:{property:'value'}, fragment: 'loading'}): this will navigate to the link link,using the
id that is added , and then using the edit sub link and then the query params will pass the properties the are passed as query params and 
a fragment loading will be added the route 

it's not good to use a click listener on a form button , as the default behavior of a form button is to send a request to the server , and that
in angular , is handled by the http service , so the best way is to have ngSubmit on the form element

#referenceElement="ngForm" : this will allow us to pass the from dom as a parameter

ngModelGroup : a directive that allows you to group elements of a form

ReactiveFormsModule: this is the module that is used for creating reactive forms module

new FormGroup({'field': new FormControl(null,validator,asyncValidator)}): this will create a new form that has field as a field in this form
and the second and third parameters can take sync and async validators for validation of your input

<form [formGroup]="fromGroupPropertyInTSCode"/> : the from group directive will allow angular to infer the form from the typescript code

<input FormControlName="name of the form control in the form group> : this will link this input with the form control specified in the ts
form group

new FormGroup({'field': new FormControl(null,Validators.required)}): this is how you add required validation in your form, validators is imported
from angular

you can have nested form groups which is equivalent to have multiple nested form groups like this
new FromGroup({'groupName': new FromGroup({'something': new FromControl('')})})

new FromArray([new FormControl()]) : allows you to add an array of form controls to your form in a reactive way 

<div formArrayName="formArrayName"> : this will synchronize your div with a form array in your typescript code

you can create custom validators in angular like this
forbiddenName(control: FormControl):{[s:string]:boolean}{
	if(condition) return {'forbiddenName':true} // this line means that the validation fails
}
notice here that in case of successful validation we return nothing , and then we pass this validator to the form control constructor

you can also create async validators that will do the same thing as sync validators but asynchronously

FormControl.valueChanges.subscribe((value)=>{
	console.log(value)
}) or FormGroup.valueChanges.subscribe() : the valueChanges observables is available on both form group or form control and it allows you to detect
changes in your form realtime , and react to changes in any form control

FormControl.statusChanges.subscribe((status)=>{
	console.log(status)
}) or FormGroup.statusChanges.subscribe() : the statusChanges observables is available on both form group or form control and it allows you to detect
the status changes in your form realtime , and react to status changes in any form control, the status values are pending , invalid and valid

pattern="regex" : this html attribute will validate the input against a certain regex

pipes are transformation techniques that allow you to transfer the interpolated string value to anything you want only in the template while
leaving the component value as it's

{{value | uppercase}} : this is the upper case pipe that transforms the value letters to uppercase

{{date string | date}}: this transforms a date string into a standard date

{{pipe:'parameter'}} : this is the way to pass parameters
example:
{{pipe:'fullDate'}} : this parameter will change the parameter format to have the full date

this is how to create a pipe 
@Pipe({name: 'theNameThatIsGoingToShowInTheTemplate'})
export class PipeName implements PipeTransform{
	transform(value:any, param:any){
		return value
	}
}
where PipeTransform is imported from angular core and transform is the transformer function that takes the value and modifies it and returns
it back , and you can pass parameters to it
YOU NEED TO ADD The PIPE TO Declarations

*ngFor="let item of array | pipe" : this syntax allows you to loop through a piped array

@Pipe({pure: false}) : this will recalculate the pipe every time the data being piped is changed , but this is very performance heavy

asynchronousValue | async : this is the async pipe that allows displaying a value that is loaded asynchronously 

if an http request isn't subscribed to in an angular app , the request won't be sent

{[key:string]: type} : this syntax means that we don't know the name of the property of the object but we know it's type

this.httpModule.get<type>(): the <type> will determine the type of the data returned by the http request

catchError : is a function from rxjs that allows you to add a function handling for errors

this.httpService.get('url',{header: new HttpHeaders({'header':'value'}) , params: new HttpParams().set('param','value')}): 
this is how you set your parameters and headers

this.httpService.get('url',{observe:'response',responseType:'Text'}): this will change the returned parsed response from the server , where 
instead of only getting the body , you will get back the whole response 
observe: 'events' : this will allow you to granularly observe your response events , like sending , received and so on 
and responseType: 'text' tells angular that the response should be only text and not converted to json , which is the default http behavior

tap : is a rxjs pipe operator that allows you to execute an action on the received data without interrupting the flow

REQUEST INTERCEPTOR:
implementing a Request httpInterceptor in angular is done the following way 
export class AuthInterceptor implements HttpInterceptor{
	intercept(req:HttpRequest<any>,next:HttpHandler){
		// your code 
			return next.handle(req)
	}
}
and then in order for the interceptor to be added to your angular app , you have to add to the app.module in the following way 
providers:[{provider:HTTP_INTERCEPTORS,useClass:AuthInterceptor,multi:true}] : multi option notifies angular that the app is going to be 
using multiple interceptors , and that angular should handle that 

in angular, request object is immutable and if you want to modify it , you have to clone the original request object using req.clone()
and pass the cloned request to the next.handle , if you are in an interceptor for example
req.clone({headers: req.headers.append('Auth','value')}) : this is how you clone the request and add extra headers

catchError : is an rxjs operator that is used to catch errors and could be used in pipes

throwError : an rxjs operator that allows you to throw errors and errors are thrown like this 
return throwError

angular components typescript files main use case is to handle ui logic  

getter: is a property of classes that allows you to run code when you reference a property in a class
and you create it like this 
export class something {
	get property (){
		// your getter code here 
	}
} 
also if you do a getter to a class property that means that you can't set it unless you add a setter to the property 

behavior subject : a like subject subscription that has the previous emitted value , even if you weren't subscribed to it 

take : is an rxjs operator that allows to take the value of the latest value of the subscription one time and then unsubscribe automatically 

exhaustMap(function) : this allows you to replace observables that it's appended to by an internal observable

the app component is one of the earliest things that run in the app 

url tree : the canActivate guard in angular allows you to return a url tree that redirects you to whatever page you want instead of doing
navigation manually and you can return a url tree like this 
this.router.createUrlTree(['/auth']) this prevents racing conditions that might occur from multiple route.navigate 

ngIf allows you to load the components dynamically

dynamic component loader : allows you to imperatively load and add components from code 

component factory : is provided by angular and allows you to add components to the dom 

entryComponents: is a feature in angular that allows you to look for your components in places other than the routing module and the html 
templates

angular doesn't search all your application code it only searches for modules that you have imported or used , so modules are the
building block of angular 

instead of importing individual components and directives and features to the app module you could bundle them into a module and import it
in the app module

bootstrap property of ng module , specifies which component is available in the index.html module which is the main entry html file 

by default declared features like directives and components are only available in the module scope you have to add an feature to the exports
array in order for you to be able to use it somewhere else
so everything in angular works as standalone and isolated from all other things 

feature module : is a module that groups features that are related to a certain feature

splitting app into modules is a prerequisite for improving your app performance

ngFor and ngIf directives are provided by the browser module

the browser module has to be only imported once in any angular app , cause it needs to be only run once cause it does angular app config
initialization

CommonModule: common module is an angular module that has a lot of angular feature and that is imported to individual modules 
and it unlocks things like ngFor and ngIf

RoutingModule.forRoot() : should be only used onces for root routes and then you can use RoutingModule.forChild() and it will automatically 
append routes to the root routes

if you add a feature module routing module you won't need to export your components anymore cause you already have them inside your module

common features should be added to a shared module to avoid code duplication
