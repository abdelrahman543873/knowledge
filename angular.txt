directives are instructions in the dom , an example of directives are components , after we create them , and then we try to place them in the dom , this is instructing angular to put them in the dom ,
there are also directives without templates , and they are created by @Directive decorator above our directive class , directives like css class could be applied as attributes to our templates in the html dom 

*ngIF="expression returning true or false" : this is a structural directive that allows angular to show a component if the expression between the "" evaluated to true
example :
*ngIF="expression; else anotherExpression"

<ng-template #noServer></ng-template> : this is an angular element that you can reference using the noServer attribute anywhere in the dom

attribute Directives : directives that doesn't remove or add elements like structural directives , it only changes the directives that it's on 

[ngStyle] = {"backgroundColor:function()"} : this is an attribute directive that is going to change the color of the element that it's on using the value returned from the function

[ngClass] = "{online: boolean expression}" : this will attach this class to the element if the expression evaluates to true 

*ngFor="let variable of list" : a structural directive that allows you to repeat an element for number of times 

{{variable}} : this is called string interpolation where you log the value of a variable from your typescript code 

ng g c something/recipes --skipTests false : allows you to generate a component without creating the testing file and it would create the recipes folder inside the something folder

ng g d value : this will generate a directive and it has all the options of generating a component

custom property binding : @input('alias'), is a property decorator , that allows the property of an component to be accessible from outside this component , if you enter the optional alias string , it will assign the value of that
alias to that property and the alias will be the way of referencing the property outside this element

<h1 (event) = "function($event)"/> : this will pass the data of this event to the function

@Output('alias') : is a property decorator for event event emitter that allows you to output event data to parent components , alias is going to be the name of the event when you reference it from outside your component
example: 
@Output() something = new EventEmitter<type>(),
now this something event could be listened to from parent elements and executed once the event was emitted

view Encapsulation: is a feature of angular that limits styles to their component only 

@Component({Encapsulation:ViewEncapsulation.None}): this will disable the view encapsulation mechanism of angular and any style you apply to this component will be applied globally

<input #localReference/> : this allows you to reference an html element locally in the same template , and then you can pass it as an input to other functions in the html template 

@ViewChild('localReference selector') classProperty : this will allow the selection of an element using the local reference selector of the element we want to select, it will return a refElement , this ref Element could be used to get 
the underlying nativeElement and then get any DOM property from the native element 

in general , everything that you place between the opening and closing of a component will be lost and won't be rendered

<ng-content></ng-content> : a directive that allows you to add html elements to your components from outside the component itself
example:
you have this component
<div>
<ng-content></ng-content> 
</div> : then any data that is added from another outside component using this component will be added between the DIVs 

lifCycle methods of components:
ngOnChanges(changes:simpleChanges): first instantiated hook and is always called when changes happens to components and by changes we mean changes in any class properties that are decorated by the @input decorator and it's the
only hook that receives a parameter which are the changes that happened
ngOnInit: second instantiated hook that is instantiated right before the component appears on the screen and it will run after the constructor
ngDoCheck : is instantiated whenever angular checks for changes on the component 
ngAfterViewInit: is instantiated when the view is initialized on the screen
ngOnDestroy: is called when the component is removed or destroyed in the dom

@ContentChild('localRef') classProperty : this allows you to access content that is rendered inside your component

[ngClass] = {'valueOfClass: condition'}: a style directive , that allows you to choose a certain class if a condition
is satisfied

@Directive({
	selector:"[appBasicHighlight]"
})
export class BasicHighlightDirective implements OnInit{
	constructor(private ElementRef:ElementRef){}

	ngOnInit(){
		this.elementRef.nativeElement.style.backgroundColor = 'green'
	}
} : this is how you create a directive , and this is going to be an attribute
directive , that could be used for styling elements , here it will change the color of any element that it's placed
on to be green and then if you want to use this directive you do this
<p appBasicHighlight></p>

constructor(private elRef:ElementRef, private renderer:Renderer2){
	this.renderer.setStyle(this.elRef.nativeElement, 'background-color','green')
}
: this is the proper way to access the element from the dom  , and this should be done inside a directive for styling elements , this is better way than the previous code 

@HostListener('mouseenter') function(){} : this allows you to interact on certain events , for example here , this function will be triggered whenever the mouse is hovered over the element of the directive

the dom properties are camel cased and the html attributes are separated using a dash

@HostBinding('style.backgroundColor') backgroundColor:string 
this.backgroundColor ='blue'
this code will allow you to access the style properties of the element that this directive will sit on 

@Input() inside a directive allows you to pass values to the directive to customize it's behavior and then if you want to pass the values you pass it like this
<p directive [directiveProperty] = "'value'"></p> or  <p directive directiveProperty = "value"></p>

*ngIf is a syntactical sugar for ng-template so this
<div *ngIf></div> is equal this <ng-template [ngIf]><div></div></ng-template> 
and that's cause angular only has property , event , two way binding and interpolation only and this * doesn't exist

you can create your own structural directive by creating a setter method of the class of the directive like this
@Directive({
	selector:'structuralDirectiveName'
})
export class(){
	@Input() set structuralDirectiveName(condition:boolean){
		your code sets here
	}
}
and then if you want to use it , you add a start before it and you need to have the property and the selector with the same name 

[ngSwitch] : this is a directive that allows you to switch views based on different conditions and it's used like this
<div [ngSwitch]="changingValue">
  <p *ngSwitchCase="5">5</p>
  <p *ngSwitchCase="6">6</p>
</div>

service injection in angular is hierarchal which means if a parent uses a service then it's inherited by it's children

@injectable({providedIn:'root'}) : is a decorator for any class that could be injected from other classes but you should add at to all classes injecting or being injected as this is the recommendation by angular 
, the parameter providedIn will make this service global because of the root value , and this is better approach cause it allows lazy loading in angular

it's best practice to initialize properties in onInit in components

const appRoutes:Routes=[{path:"users",component:Component,children:[{path:"",component:Component}]}] : this is where you place the routes of the app , that
allows you to navigate between components , the path is the string that is place after the url of the website and 
the component is what get loaded when you go to that url , and the children route will allow you to go to another child route , which means it will be an extension of the main route

RouterModule.forRoot(appRoutes) : this will control the routes of your app and it's imported in the app module

<router-outlet></router-outlet> : this directive tells angular where to render the component of the route

<a routerLink="/"></a> : this will make angular handle the routing which will prevent the app from reloading with
with each click which is the normal behavior if we use href
routerLink="path" : this will navigate to the relative path
routerLink="/path" : this will navigate to the absolute path

routerLinkActive="active" : this will change the style of the selected routing element to active in this case to 
mark that it's selected 

[routerLinkOptions]="{exact:true}" : this angular property is used for configuring the options for the routerLinkActive
directive , and the exact make links activate if they are only refereed to exactly

[queryParams] = {allowEdit:true} : this is a parameter option for routerLink that allows you to add query parameters to the router

fragment = "value" : a fragment option of routerLink that adds a fragment to the route

this.router.navigate(['servers'],{relativeTo:'the base router you want',queryParamsHandling:'preserve'}) : the router service that is injected in the constructor allows you to navigate 
to other routes "/ or no / doesn't matter" using the navigate function , and the relative to property determines the base route
queryParamsHandling: this will determine what happens if you redirect from this route and in this case it will preserve the route parameters

this.activatedRoute : this will get you the route of the current component that you are in 

this.activatedRoute.snapshot.params['id'] : this will use the activated Route service of angular and get the id parameter from the url , this is static , and will be only loaded when the component first initializes

this.activatedRoute.params.subscribe((params:Params)=>{your code}) : this code will get executed whenever the parameters of the route gets changed  "use this only when your component is could be reloaded from inside itself" 

this.activatedRoute.queryParams and this.activatedRoute.snapshot.queryParams and the same exist for fragment to with the same methodology

[routerLink]="['/users',10,'something'] : this is the best way to pass url to router link , it will construct the following url , something.com/user/10/something

const path = [{path:"users/:id",component:Component}] : this is how to pass parameters to a url
const path = [{path:"users/:id",redirectTo:'path'}] : in the case this url was typed , it will redirect to another path , because of the the redirect to property 

const path = [{path:"**",component:Component}] : in this case the ** means that all the routes that aren't included will be redirected to this component and it has to be the last route cause order 
is very important when it comes to routes

const path = [{path:"users/:id",redirectTo:'path', pathMatch:'full'}] : this will redirect only to full path of the url in path and will avoid redirecting to paths that has the same partial url

@NgModule({})
export class module{} : this is how you create modules in angular

export class AuthGuard implements canActivate {
	canActivate(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean{
		your code logic that returns true or false
		and if false it should redirect to another 
		webpage using 
		this.Router.navigate() function
	}
	canActivateChild(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean{
		your code logic that returns true or false
		and if false it should redirect to another 
		webpage using 
		this.Router.navigate() function
		this allows you to protect child routes without having to manually place the can activate on children paths
	}
}

const path = [{canActivate:[GuardService],canDeactivate:[guard], path:"users/:id",component:Component}] : the can deactivate guard allows you to either leave the route or not 

const path = [{path:"**",component:Component, data:{}}] : this allows you to pass data to the component and then if you want to access this data you do it like this
this.activatedRoute.snapshot.data['the property you want to access'] or you can subscribe to the data Observable like this this.route.data.subscribe()

export class serverResolver implements Resolve<DataTypeToBeResolved>{
	resolve(route:ActivatedRouteSnapshot,state:RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {}
}

const path = [{path:"**",component:Component, resolve:{propertyName:ResolverServiceName}}] : the resolve property will allow you to load data dynamically before loading the component and it will map it to the propertyName property
and it's accesses using this.activatedRoute.subscribe((propertyName)=>{}) to get the data 

RouterModule.for(appRoutes,{useHash:true}): useHash allows for the legacy # in the routes to allow for better redirection when the angular app is hosted online 

onDestroy is triggered whenever the component is destroyed like for example when you leave the component

the observer in the rxjs create observable method , has three methods
error : what is thrown to the observer when there is an error
next : what is throw to the observer when data is emitted
complete : when the observable is done what is thrown to the observer 
it looks like this 
const customObservable = Observable.create(observer=>{observer.error(new Error() 'errorObject') or observer.next(dataYouWantToPass) or observer.complete()})
if i would like to handle everything coming from this observable it would be like this
customObservable.subscribe(data=>{console.log('data')},error=>{console.log(error),()=>{console.log('completion')}})

in observables completion is different that errors , if your observers throws an errors then it doesn't complete , it's two different things

operators : are transformations that you could apply on the data before receiving it on the observer side , using this function
observable.pipe('use functions from rxjs like map','another rxjs function', ....).subscribe() : this is the way to use operators with observables

subject : is a special type of observable that is more interactive where you can trigger the next function from outside the subject not from the inside as in the case of the normal observable 
and it can't be used with the @Output from angular

two templates approaches are available in angular :
template-driven : where you make you html template 
reactive approach : where the form is created from the code and synchronized with the dom 

ngModel : inside forms , this is an angular directive that allows you to control a form element from the dom , and it's syntax is like this
<input type="text" ngModel name="theNameThatIsGoingToBeRepresentedInTheDom"/>

ngSubmit : is an angular event that makes use of the default behavior of the submit button on a form , it's placed on forms like this
#localRef="ngForm" : this gives you access to the form object created by angular "the type of ngForm is ngForm" 
ngForm.value : this is the object you want to access to get the values of the elements you have referenced by ngModel in the form 
<form (ngSubmit)="theFunctionYouWantToTrigger(anyName)" #anyName="ngForm">
<button type="submit"></button>
</form>
here in the previous code we triggered a function on submitting the form and in this function we passed the ngForm object created by angular
you can access the anyName local reference by either passing it through the function or using @ViewChild('anyName') like this
@ViewChild('anyName') propertyName , and this way is used if you need to access the form at any other point other than submitting the form

required: a validation html attribute that angular treats as a directive , that makes sure the element value isn't null it's used like this 
<input type="text" name="something" required/>

email : is a validator directive in angular that validates if an input is an email or not

valid : a property of the ngForm that checks if all your form validation is valid or not and it's a property of the individual form elements too 

localRef.value : you can access the properties of the local reference of elements using the normal dot notation in the html 
example
<button [disabled]="formLocalRef.valid != true"></button> : this will only enable the submit button if the form validation passes 

input.ng-invalid {
	border:1px solid red
}: this is an example of how to make the border become red if the input that the user is passing is invalid

<input type="email" ngModel #email="ngModel"/>: this will allow you to access the email input properties like this for example
<span *ngIf="!email.valid>wrong email</span> : this will show a message error if the input value of the email is wrong 

<select [ngModel]="'value'"> : this allows you to choose a default value for the select 

[(ngModel)]="classProperty" : this will be a reactive approach to the input the user is entering 

@ViewChild('selector') something
something.setValue({propriety of the element selected and their values}) : this will override the values of the whole form
something.form.patchValue({property you want to override}) : this will override only the value of the property you pass 
something.reset() : resets the whole form for you 