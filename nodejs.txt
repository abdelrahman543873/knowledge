buffering is the act of saving all data and then sending all of it as one blob of data to the receiver

streaming : the process of sending the data to the receiver as soon as it's emitted from the sender 

buffers in nodejs v8 engine are limited to a couple of gbs and it's a variant between OS

a scenario where buffers could be a handicap , is when you are buffering a big file where it's size will be more than the size of the buffer
of the v8 engine 

process.argv[2] : this is how you read a parameter from the command when you are running the file

createReadStream(filename)
  .pipe(createGzip())
  .pipe(createWriteStream(`${filename}.gz`))
  .on('finish', () => console.log('File successfully compressed')): creates a read stream and then pipes the result to createGzip function
  which creates a gzip from the stream and then passes the data to create write stream


stream chunks processing "whatever the processing is" is done in parallel and this is handled by nodejs , which is way better than the buffered approach

the abstract class types of streams are : readable , writable , duplex and transform

streams can handle any js value through two modes
binary mode : streaming data in form of chunks such as buffers or strings
object mode : streaming data as a sequence of discrete objects

readable streams are sources of data and are implemented using the steam readable abstract module

flowing mode : is a mode when reading from a stream 

non-flowing mode : the default reading mode from streams where a listener on the stream of data is listening for the read event 

stdin : the standard input is a readable stream 

highWaterMark : is the limit of the internal buffer of streams , where any writable stream would return false if writing exceeds the highWaterMark

backPressure: an advisory mechanism for the limit of internal buffers of streams , it's important to respect backPressure , it also exist in 
readable streams 

duplex : is a writable and readable at the same time 

transform streams : are a special kind of duplexes that are specially used for transformations

pass through streams : are streams where data is passed by without any processing 

observability : attaching an event listener onData allows you to track how much data is passing through the stream

lazy stream : delaying the initialization of streams until wanting to actually consume data from them  and there is a library that is called
lazyStream that allows you to create lazy stream instances 

forking streams : is dividing the readable of two streams into two writables , which allows us to do things like multiple operations on the 
data at the same time 

merging streams : is an operation opposite to forking as it pumps multiple readable streams into a single writable 

design pattern : is a reusable solution to a recurring problem

creational design patterns : are patterns that address the problem of object creation , for example the revealing constructor pattern , 
exposes the object's properties and methods only during object creation 

factory design pattern : factory is a functional design pattern that enforces encapsulation by leveraging javascript features like closures
and it simply abstracts the creation of a class object by rapping it with a function and this function is the factory function, and this
way you can separate object creation from it's implementation

factory design pattern limits the access to classes and prevents their modification by only exposing the factory and keeping classes hidden cause 
it only exposes a public interface that allows you to deal with the factory

encapsulation : is preventing external code from manipulation of internal details of an encapsulated element like it's properties or it's methods

per new es6 syntax you don't need to add property names when defining functions inside objects you can just do this 
const something={something(){}}

you cna make properties of a class private by prefixing them with # or having them as private variables of the constructor of the class

builder pattern : a design pattern that eases the creation of classes or calling methods that has long list of arguments by creating methods
that assign those parameters to the instantiation of the class 

superagent library for testing are actually using the builder pattern

revealing constructor pattern : this pattern allows you to run functionality only while the initialization a class 
example:
const something = new RevelingConstructor((reveled parameters)=>{})
real life example : 
const  promising = new Promise((resolve, reject)=>{})

purposes of using singleton pattern : 
sharing stateful information
optimizing resource usage
synchronize access to a resource

singleton pattern : allows only one instance of a class to be used by the whole project, simply exporting the class will be enough and make 
it only used once cause the module system of nodejs will cache the exported module
or you can have a global variable with the instance you need of the class 

dependency injection pattern : this pattern allow looser coupling between modules , it's different than the traditional module importing in 
the fact that it allows for easier mocking of dependencies 

injector : is the provider of the required service in the dependent module 

inversion of control : is when you are leaving the control of the application to the framework itself or to a third party package

structural design patterns : design patterns that are related to relations between project entities

proxy pattern : a proxy is an object that controls access to another object called subject

multiple functionalities could be achieved through proxy , like data validation, security, caching, Lazy initialization and logging and remote
objects

ES15 proxy object : a built in proxy object that allows you to add a proxy to any object like this 
const proxy = new Proxy(subject, handler)

trap methods : methods like apply, get, set and has this methods could be overridden using proxy

polyfill : is conversion of functionality of APIs to plain js to import in other places where this api doesn't exist

Object Composition :  whereby an object is combined with another object for the purpose of extending or using its functionality

function delegation : is delegating the functionality of an entity like a function to another party like another class 

object augmentation 'monkey patching': is a proxy pattern implementation by modifying the subject directly and overriding a function of it 
directly , object augmentation or monkey patching is a dangerous approach that should be used at caution 

proxy es object has limitation that it can't be polyfilled or transpiled cause some of it's traps only gets executed at runtime , this is abstract
limitation when it comes to old browsers using js  

Transpilation : conversion of code from one programming language to another in case of js , it from one version to an older one so that it can
be run on older devices

behavioral design patterns : are patterns that are concerned with the interaction between different parts of any software

strategy design pattern : this pattern allows an object called context to have different variations of it's logic in separate objects called
strategies, the context holds the common logic across all the strategies

strategy pattern is particularly useful for conditions where you have to use a lot of if conditions

state pattern : state pattern is a specialization of the strategy pattern where the strategy is changed based on the state of the object

change observer pattern : is a design pattern where the subject notifies one or more changes of any changes that happen , so they can react
to those changes 

decorator pattern : is a design patter that augments the behavior of an object by adding functionalities and properties, it's different from
classical inheritance that it doesn't add the functionality to all the objects of the class , it adds it only the instance that is decorated 

decorator pattern is different from proxy in that it doesn't modify the existing subject by modifying it's functionality rather it adds new
functionality to it 

you can do object decoration through object augmentation

you can decorate with proxy object

adapter design pattern : allows us to use an object functionality with a different interface than it's original one 

in adapter pattern you have the adapter and adaptee , which is the entity used by the adapter 